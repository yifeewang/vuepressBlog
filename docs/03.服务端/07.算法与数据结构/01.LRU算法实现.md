---
title: LRU算法实现
date: 2022-06-29 15:27:16
permalink: /pages/84f782/
categories:
  - 全栈
  - 算法与数据结构
tags:
  - 
---

### 1.什么是 LRU？
LRU 英文全称是 Least Recently Used，英译过来就是”最近最少使用“的意思。 它是页面置换算法中的一种，我们先来看一段百度百科的解释。

百度百科：
LRU 是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。

百度百科解释的比较窄，它这里只使用了页面来举例，我们通俗点来说就是：假如我们最近访问了很多个页面，内存把我们最近访问的页面都缓存了起来，但是随着时间推移，我们还在不停的访问新页面，这个时候为了减少内存占用，我们有必要删除一些页面，而删除哪些页面呢？我们可以通过访问页面的时间来决定，或者说是一个标准：在最近时间内，最久未访问的页面把它删掉。

通俗的解释：
假如我们有一块内存，专门用来缓存我们最近访问的网页，访问一个新网页，我们就会往内存中添加一个网页地址，随着网页的不断增加，内存存满了，这个时候我们就需要考虑删除一些网页了。这个时候我们找到内存中最早访问的那个网页地址，然后把它删掉。
这一整个过程就可以称之为 LRU 算法。

### 2.使用场景
LRU 算法使用的场景非常多，这里简单举几个例子即可：

>   我们操作系统底层的内存管理，其中就包括有 LRU 算法
>   我们常见的缓存服务，比如 redis 等等
>   比如浏览器的最近浏览记录存储

总之 LRU 算法的运用场景还是蛮多的，所以我们很有必要掌握它。

### 3.梳理实现 LRU 思路

#### 特点分析：
* 我们需要一块有限的存储空间，因为无限的化就没必要使用 LRU 算发删除数据了。
* 我们这块存储空间里面存储的数据需要是有序的，因为我们必须要顺序来删除数据，所以可以考虑使用 Array、Map 数据结构来存储，不能使用 Object，因为它是无序的。
* 我们能够删除或者添加以及获取到这块存储空间中的指定数据。
* 存储空间存满之后，在添加数据时，会自动删除时间最久远的那条数据。

#### 实现需求：
* 实现一个 LRUCache 类型，用来充当存储空间
* 采用 Map 数据结构存储数据，因为它的存取时间复杂度为 O(1)，数组为 O(n)
* 实现 get 和 set 方法，用来获取和添加数据
* 我们的存储空间有长度限制，所以无需提供删除方法，存储满之后，自动删除最久远的那条数据
* 当使用 get 获取数据后，该条数据需要更新到最前面
* 现在我们已经把 LRU 算法的特点以及实现思路列了出来，那么接下来就然我们一起去实现它吧！

### 4.具体实现
```js
class LRUCache {
    // 初始化
    constructor(length) {
        this.length = length;
        this.data = new Map();
    }
    // 存储数据，通过键值对的方式
    set(key, val) {
        const data = this.data;
        if(data.has(key)) {
            data.delete(key)
        }
        data.set(key, val)

        if(data.size > this.length) {
            const getKey = data.keys().next().value;
            data.delete(getKey)
        }
    }
    // 获取数据
    get(key) {
        const data = this.data;
        if(!data.has(key)) {
            return null
        }
        const val = data.get(key);
        data.delete(key);
        data.set(key, val);
        return val;
    }
}

const lruCache = new LRUCache(5);

```

上段代码中实现实现了 get 和 set 方法，下面说一下这两个方法的实现思路。

set 方法：往 map 里面添加新数据，如果添加的数据存在了，则先删除该条数据，然后再添加。如果添加数据后超长了，则需要删除最久远的一条数据。data.keys().next().value 便是获取最后一条数据的意思。
get 方法：首先从 map 对象中拿出该条数据，然后删除该条数据，最后再重新插入该条数据，确保将该条数据移动到最前面。
接下来我们使用一些测试用例来试试行不行。


LRU 算法其实逻辑非常的简单，明白了原理之后实现起来非常的简单。最主要的是我们需要使用什么数据结构来存储数据，因为 map 的存取非常快，所以我们采用了它，当然数组其实也可以实现的。还有一些小伙伴使用链表来实现 LRU，这当然也是可以的。